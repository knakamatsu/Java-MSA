= 30分で作るマイクロサービス・アーキテクチャ
nobusugi246
2017-02-12
:library: Asciidoctor
:idprefix:
:numbered:
:css-signature: demo
:toc: left
// :toc-placement: preamble
:toclevels: 5
// :example-caption: List
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]

30分でマイクロサービス・アーキテクチャを構築する方法を説明します。
Spring Cloudを利用します。


== 事前準備

以下がインストールされて、利用できるとします。

. *Java SE 8* : 以下からダウンロードしてください。 +
  http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
. *Gradle* : 以下から Ver.3.2以降をダウンロードして、実行できるように設定してください。 +
  https://gradle.org/gradle-download/ +
  Macまたは Linuxでは、以下の SDKMANを利用すると便利です。 +
  http://sdkman.io/ +
  SDKMANでは、以下でインストール/アップデートできます。 +
  `$ sdk i gradle`
. *Spring Boot CLI* : Spring Bootには、コマンドラインから実行する便利なユーティリティ機能があります。これを利用した手順で説明します。 +
  http://docs.spring.io/spring-boot/docs/1.4.4.RELEASE/reference/htmlsingle/#getting-started-installing-the-cli +
  このユーティリィは、コマンドラインから以下の Spring Initializrにアクセスし、
  指定した条件で作成したプロジェクトの雛形をダウンロードして、展開できます。 +
  http://start.spring.io/ +
  SDKMANでは、以下でインストール/アップデートできます。 +
  `$ sdk i springboot`
. *Spring Tool Suite* (オプション): Eclipseのプラグインで、Springによる開発を協力に支援します。 +
  今回、動作確認するために必須では無いですが、利用をお勧めします。
  以下からダウンロードするか、Eclipseのマーケットプレイスからダウンロードして利用します。 +
  https://spring.io/tools/sts/all  

NOTE: 最近の SDKMANは、Javaも以下でインストール/アップデートできます。 +
`$ sdk i java`

NOTE: SDKMANは他に、Groovy、Grails、Kotlin、Scala/sbt、などをインストール/アップデートできます。

NOTE: Intellij IDEAを利用する場合は、後述する `build.gradle` に、以下を記述します。 +
`apply plugin: 'idea'` +
後は同様に `./gradlew idea` により IDEAのプロジェクト定義ファイルを生成し、
IDEAから `open` によりプロジェクトを読み込んでください。


== 作成するマイクロサービス・アーキテクチャ

以下の構成のマイクロサービス・アーキテクチャを作成します。

.マイクロサービス・アーキテクチャ
====
[plantuml, Microservices-Architecture, png]
....
skinparam componentStyle uml2

Actor Browser
Browser -> [API Gateway]
[API Gateway] -> [FrontendService]
[FrontendService] -> [ContentsService]

[API Gateway] --> [ServiceDiscovery]
[ServiceDiscovery] <- [AdminService]
....
. API Gateway : `gw` というプロジェクトとして作成します。
  Netflix OSSの Zuulという機能を、Springから利用します。
  ブラウザ等からの RESTリクエストを、設定に応じて他のマイクロサービスに振り分けます。
. ServiceDiscovery : `discovery` というプロジェクトとして作成します。
  マイクロサービスの登録、検索を行なうためのマイクロサービスです。
  Netflix OSSの Eurekaという機能を、Springから利用します。
  各マイクロサービスは自分が起動するときに、自分への参照を自動的に登録します。
. AdminService : `admin` というプロジェクトとして作成します。
  `ServiceDiscovery` に登録されたマイクロサービスを、自動的に管理対象とします。 +
  各マイクロサービスを実現している Spring Bootの Actuatorという機能を利用します。
  これにより各マイクロサービスの状態を知ることができます。 +
  管理には、以下の OSSを利用します。 +
  https://github.com/codecentric/spring-boot-admin +
  https://github.com/ordina-jworks/microservices-dashboard +
. FrontendService : `frontend` というプロジェクトとして作成します。
  SPAの画面(HTML等)を配布し、その画面と直接連携します。
  Bootstrapと jqueryを利用できる様に準備するところまで作成します。
. ContentsService : `contents` というプロジェクトとして作成します。
  Spring Data RESTにより、
  REST APIでデータベースを操作できる様に準備するところまで作成します。
====

NOTE: Actuatorは、マイクロサービスの実行状態として、DBへの接続情報、
Javaの Minor/Major GCの実行回数や実行時間、ログ、スレッドダンプ、ヒープダンプ、
などを REST APIにより取得できます。詳細は以下を参照してください。 +
http://docs.spring.io/spring-boot/docs/1.4.4.RELEASE/reference/htmlsingle/#production-ready

NOTE: Spring Data RESTは、JPAなどの Beanを定義することで、
それを操作する RESTの APIを自動生成することができます。
詳細は、以下を参照してください。 +
http://projects.spring.io/spring-data-rest/ +
https://spring.io/guides/gs/accessing-data-rest/

ここから 30分です。


== マイクロサービスの雛形を作成

マイクロサービスの雛形を、 `Spring Boot CLI` により作成します。
`spring` というコマンドが利用できるようになります。
幾つかの機能がありますが、ここではプロジェクトの雛形を作成する initという機能を利用します。

init機能についての helpは以下です。

.Spring Boot CLIの init機能の help
====
----
$ spring help init
spring init - Initialize a new project using Spring Initializr (start.spring.io)

usage: spring init [options] [location]

Option              Description                            
------              -----------                            
-a, --artifactId    Project coordinates; infer archive     
                      name (for example 'test')            
-b, --boot-version  Spring Boot version (for example       
                      '1.2.0.RELEASE')                     
--build             Build system to use (for example       
                      'maven' or 'gradle') (default: maven)
-d, --dependencies  Comma-separated list of dependency     
                      identifiers to include in the        
                      generated project                    
--description       Project description                    
-f, --force         Force overwrite of existing files      
--format            Format of the generated content (for   
                      example 'build' for a build file,    
                      'project' for a project archive)     
                      (default: project)                   
-g, --groupId       Project coordinates (for example 'org. 
                      test')                               
-j, --java-version  Language level (for example '1.8')     
-l, --language      Programming language  (for example     
                      'java')                              
-n, --name          Project name; infer application name   
-p, --packaging     Project packaging (for example 'jar')  
--package-name      Package name                           
-t, --type          Project type. Not normally needed if   
                      you use --build and/or --format.     
                      Check the capabilities of the        
                      service (--list) for more details    
--target            URL of the service to use (default:    
                      https://start.spring.io)             
-v, --version       Project version (for example '0.0.1-   
                      SNAPSHOT')                           
-x, --extract       Extract the project archive. Inferred  
                      if a location is specified without   
                      an extension                         

examples:

    To list all the capabilities of the service:
        $ spring init --list

    To creates a default project:
        $ spring init

    To create a web my-app.zip:
        $ spring init -d=web my-app.zip

    To create a web/data-jpa gradle project unpacked:
        $ spring init -d=web,jpa --build=gradle my-dir
----
====

`spring` コマンドにより、以下の様に各プロジェクトの雛形を作成します。

.各マイクロサービスの雛形を作成
====
[source%nowrap]
----
$ spring init discovery -d=actuator,cloud-eureka-server --build=gradle --package-name proto
$ spring init admin     -d=actuator,cloud-eureka --build=gradle --package-name proto
$ spring init gw        -d=actuator,cloud-eureka,cloud-zuul,cloud-ribbon --build=gradle --package-name proto
$ spring init frontend  -d=actuator,cloud-eureka,devtools,web,thymeleaf --build=gradle --package-name proto
$ spring init contents  -d=actuator,cloud-eureka,devtools,data-jpa,data-rest,h2 --build=gradle --package-name proto
----
. `init` の次に記述しているのが、プロジェクト名であり、フォルダ名になります。
. `-d` オプションでは、利用する Springの機能(ライブラリ)を指定しています。
全てのプロジェクトで、 `actuator` という機能を利用しています。
これは Spring Bootの機能で、各マイクロサービス自身が、
監視されるために用意されている標準的なものです。 +
`cloud-eureka-server` は `ServiceDiscovery` を実現している機能です。 +
`cloud-eureka` は `ServiceDiscovery` を利用するための機能です。 +
`cloud-zuul` や `cloud-ribbon` は、リクエストを振り分けるルーティングの機能です。 +
. `--build=gradle` は、Gradleによるプロジェクトの定義を生成します。 +
. `--package-name` は、生成される Javaのパッケージ名を指定します。
====

NOTE: `-d` オプションで指定できる機能は、以下で一覧を表示できます。 +
`$ spring init --list`


上記の `spring` コマンドを実行した直後の、
各マイクロサービスの雛形のフォルダ構成と、主なファイルは以下の様になっています。

.各マイクロサービスの雛形作成直後のフォルダ構成
====
----
▾ admin/          // <1>
  ▸ gradle/       // <2>
  ▸ src/          // <3>
    build.gradle  // <4>
    gradlew       // <5>
    gradlew.bat   // <6>
▾ contents/
  ▸ gradle/
  ▸ src/
    build.gradle
    gradlew
    gradlew.bat
▾ discovery/
  ▸ gradle/
  ▸ src/
    build.gradle
    gradlew
    gradlew.bat
▾ frontend/
  ▸ gradle/
  ▸ src/
    build.gradle
    gradlew
    gradlew.bat
▾ gw/
  ▸ gradle/
  ▸ src/
    build.gradle
    gradlew
    gradlew.bat
----
<1> `admin` プロジェクトを例に説明します。
<2> gradle の wrapperという機能のための設定が配置されています。
今回は、全体で一つ用意するので、 *各プロジェクトのこのフォルダは削除します* 。
<3> 各マイクロサービスをプロセスとして実行するために、最低限必要なコードが用意されています。
<4> 各マイクロサービスを構築するためのライブラリの設定などが記述されています。
<5> gradle の wrapperを、Linuxや Macで利用するためのスクリプトです。
今回は、全体で一つ用意するので、 *各プロジェクトのこのファイルは削除します* 。
<6> gradle の wrapperを、Windowsで利用するためのスクリプトです。
今回は、全体で一つ用意するので、 *各プロジェクトのこのファイルは削除します* 。
====

全てのプロジェクトを同時にビルドしたり、共通設定を定義などするために、
`build.gradle` ファイルを用意します。まずは空のファイルで良いです。

また、この時にどのプロジェクトを対象とするかを記述する、
`settings.gradle` というファイルを、各プロジェクトが配置されているフォルダに用意します。

.settings.gradleファイル
====
----
include::../../../settings.gradle[]
----
====

また、全体で共通に利用するための `gradle wrapper` を設定するために、
各プロジェクトが配置されているフォルダで、以下を実行します。

.gradle wrapperの設定
====
----
$ gradle wrapper
----
====

これらにより、最終的なフォルダ構成と主なファイルは以下になります。

.最終的なフォルダ構成
====
----
build.gradle      //<1>
gradlew           //<2>
gradlew.bat       //<3>
settings.gradle   //<4>
▾ admin/
  ▸ src/
    build.gradle
▾ contents/
  ▸ src/
    build.gradle
▾ discovery/
  ▸ src/
    build.gradle
▾ frontend/
  ▸ src/
    build.gradle
▸ gradle/           //<5>
▾ gw/
  ▸ src/
    build.gradle
----
<1> 全体で共通に利用する `build.gradle` ファイル。内容は空のファイルで OK。
必要に応じて、共通の設定やタスクを記述しておく。
<2> 全体で共通に利用する gradle wrapperの Mac/Linux用スクリプト。
<3> 全体で共通に利用する gradle wrapperの Windows用スクリプト。
<4> 共通にビルド等を行なう対象とするプロジェクトを指定する設定ファイル。
<5> 全体で共通に利用する gradle wrapperの設定が配置されている。
====


== ライブラリの追加

`Spring Boot CLI` では設定できないライブラリを、追加で指定します。
各プロジェクト毎の `build.gradle` ファイルに追記します。

=== discoveryプロジェクト

discoveryプロジェクトにライブラリの追加は必要ありません。

=== adminプロジェクト

Spring Boot Admin と Microservices Dashboard を利用するための設定を追加します。

.adminプロジェクトの build.gradleファイルへの追記
====
[source, groovy]
----
include::../../../admin/build.gradle[tags=deps]
----
<1> Spring Boot Adminのための追加設定(1/2)
<2> Spring Boot Adminのための追加設定(2/2)
<3> Microservices Dashboardのための追加設定
<4> `spring` コマンドを実行した時期により、安定版か開発版がここに自動的に設定されます。
必要に応じて、どちらを利用するかを判断して設定を変更します。今回は安定版としています。
====

=== gwプロジェクト

gwプロジェクトにライブラリの追加は必要ありません。

=== frontendプロジェクト

Bootstrapや jqueryを、jarの依存関係を定義することで、利用するための設定を追加します。

NOTE: ここでは `webjars` というライブラリを利用しています。
JavaScript や CSSのライブラリを、Jarにより管理できます。 +
http://www.webjars.org/


.frontendプロジェクトの build.gradleファイルへの追記
====
[source, groovy]
----
include::../../../frontend/build.gradle[tags=deps]
----
<1> Bootstrapを webjarsにより追加します。
<2> jqueryを webjarsにより追加します。
<3> (オプション) Spring Boot Adminから、
実行中のマイクロサービスが出力するログレベルを変更できる様にする場合に追加します。
このマイクロサービスには、今後、 `Controller` や `Service` を実装しますので、
その開発や運用時の調査のために使用できます。
====

=== contentsプロジェクト

利用するデータベースのドライバを追加します。

.contentsプロジェクトの build.gradleファイルへの追記
====
[source, groovy]
----
include::../../../contents/build.gradle[tags=deps]
----
<1> (オプション) Spring Data RESTにより生成された REST APIをブラウザで閲覧できるようにします。
<2> (オプション) Spring Boot Adminから、
実行中のマイクロサービスが出力するログレベルを変更できる様にする場合に追加します。
<3> (オプション) Java Beanの Setter/Getter等を自動生成できるようにします。
<4> 使用するデータベースのドライバを追加します。
====


== アノテーションの追加

各プロジェクトに設定されているライブラリを利用するために、
`main` 関数が定義されているクラスに、アノテーションを追加します。

import文は開発環境が自動的に追加してくれます。

=== discoveryプロジェクト

.discoveryプロジェクトの DemoApplication.javaへのアノテーションの追加
====
[source, java]
----
include::../../../discovery/src/main/java/proto/DemoApplication.java[tags=anotations]
----
<1> `ServiceDiscovery` (Eurekaのサーバ機能)を
マイクロサービスとするために追加するアノテーション。
====

=== adminプロジェクト

.adminプロジェクトの DemoApplication.javaへのアノテーションの追加
====
[source, java]
----
include::../../../admin/src/main/java/proto/DemoApplication.java[tags=anotations]
----
<1> `ServiceDiscovery` を利用するために追加するアノテーション。
これにより、起動時に自動的に自分への参照を、`ServiceDiscovery` に登録します。
<2> Spring Boot Adminのサーバ機能を利用するために追加するアノテーション。
<3> Microservices Dashboardのサーバ機能を利用するために追加するアノテーション。
====

=== gwプロジェクト

.gwプロジェクトの DemoApplication.javaへのアノテーションの追加
====
[source, java]
----
include::../../../gw/src/main/java/proto/DemoApplication.java[tags=anotations]
----
<1> API Gatewayとしてのリバースプロキシー機能である、Zuulを利用するために追加するアノテーション。
<2> `ServiceDiscovery` を利用するために追加するアノテーション。
これにより、起動時に自動的に自分への参照を、`ServiceDiscovery` に登録します。
====

=== frontendプロジェクト

.frontendプロジェクトの DemoApplication.javaへのアノテーションの追加
====
[source, java]
----
include::../../../frontend/src/main/java/proto/DemoApplication.java[tags=anotations]
----
<1> `ServiceDiscovery` を利用するために追加するアノテーション。
これにより、起動時に自動的に自分への参照を、`ServiceDiscovery` に登録します。
====

=== contentsプロジェクト

.contentsプロジェクトの DemoApplication.javaへのアノテーションの追加
====
[source, java]
----
include::../../../contents/src/main/java/proto/DemoApplication.java[tags=anotations]
----
<1> `ServiceDiscovery` を利用するために追加するアノテーション。
これにより、起動時に自動的に自分への参照を、`ServiceDiscovery` に登録します。
====

== 設定ファイルの作成

雛形作成時に各プロジェクトには、設定ファイルとして `application.properties` が作成されますが、
多くの設定を記述する場合は、yaml形式の方が記述しやすいです。
以下ではyaml形式での設定例を示します。

`application.properties` ファイルは削除し、
`application.yml` ファイルを作成します。

=== discoveryプロジェクト

.discoveryプロジェクトの設定ファイル
====
[source, yaml]
----
include::../../../discovery/src/main/resources/application.yml[]
----
<1> サービスがリクエストを受け付けるポート番号を設定。
<2> Actuatorの `/info` エンドポイントで取得される情報を追加する。
ここではキー `name` と、バリュー `ServiceDiscovery` を設定。
<3> アプリケーションの名称を設定。これが `ServiceDiscovery` にキーとして登録される。
<4> コンソールへのログに常に色が付くように設定。
<5> 起動時に自動的に自分への参照を登録する、 `ServiceDiscovery` がどこにあるかを設定。
(この場合は、自分自身)
<6> ログファイルを出力するフォルダ名/ログファイル名を設定。
====

=== adminプロジェクト

.adminプロジェクトの設定ファイル
====
[source, yaml]
----
include::../../../admin/src/main/resources/application.yml[]
----
<1> Spring Boot Adminを利用するときのコンテキスト・パスを設定。
これにより http://localhost:8110/admin のようなパスとなる。 +
デフォルトでは `/` だが、このパスは今回は `Microservices Dashboard` が利用するため、
Adminへのパスを変更している。
====

=== gwプロジェクト

.gwプロジェクトの設定ファイル
====
[source, yaml]
----
include::../../../gw/src/main/resources/application.yml[]
----
<1> ブラウザ等からのリクエストを、他のマイクロサービスに振り分ける設定。 +
例えばこの設定では、 `http://localhost:8000/front/**` に来たリクエストを、
`FrontendService` というキーで `ServiceDiscovery` に登録されているマイクロサービスへ、
振り分けを行ないます。
====

=== frontendプロジェクト

.frontendプロジェクトの設定ファイル
====
[source, yaml]
----
include::../../../frontend/src/main/resources/application.yml[]
----
====

=== contentsプロジェクト

.contentsプロジェクトの設定ファイル
====
[source, yaml]
----
include::../../../contents/src/main/resources/application.yml[]
----
====

== マイクロサービスの起動

最初に起動したときは、利用するライブラリをダウンロードするため、
少し時間がかかります。お茶を飲みながら、気長におまちください。

=== Gradleによる起動

これは動作確認のための、簡易的な起動方法です。
本番環境での起動には向きません。
すべてのマイクロサービスを、Gradleから並列に起動します。

.Gradleによる起動
====
----
$ ./gradlew bootRun --parallel --max-workers=5
----
====

問題が無ければ、CPUの負荷がさがった時点で、全てのマイクロサービスが起動しているはずです。

停止するには、起動を行なったターミナルで、 `Ctrl-C` を入力します。

IMPORTANT: `--parallel` と `--max-workers` オプションは、
まだ正式なオプションではない(incubating)ため、
今後も同様に動作するとは限りません。

=== Eclipse(Spring Tool Suite)による起動

まず、全てのマイクロサービスについて、Eclipseのプロジェクト定義ファイルを生成します。

.Eclipseのプロジェクト定義ファイルの生成
====
----
$ ./gradlew eclipse
----
====

Spring Tool Suiteを起動します。
最初に、パースペクティブが Springであることを確認します。
以下の様に、Eclipseの右上の表示を確認します。

.パースペクティブの確認 (若葉?マークがアクティブであれば良い)
image::perspective.png[]

次に、上記で作成した全てのマイクロサービスのプロジェクトを、インポートします。

メニューから [File] -> [Import...] ->
General の下の Existing Projects into Workspace を選択して [Next >]ボタンを押下。
Select root directory を入力し、
すべてのマイクロサービスのプロジェクトを選択してインポートします。

以下の様に、左上の Package Explorerで表示されれば良いです。

.すべてのマイクロサービスのプロジェクトをインポートしたところ
image::import.png[]

次に、Eclipseの左下にあるビューの、Boot Dashboardを使用して、マイクロサービスを起動します。

.Boot Dashboardの表示 (初期表示)
image::bootdashboard_1.png[]

全てのマイクロサービスを同時に起動できますが、
discoveryプロジェクト(ServiceDiscovery)から起動するのが丁寧です。

discoveryプロジェクトをマウスで選択し、左上の起動ボタンを押下して起動します。

.Boot Dashboardにより discoveryプロジェクトを起動するところ
image::bootdashboard_2.png[]

以下の様に表示されれば OKです。

.Boot Dashboardにより discoveryプロジェクトが起動したところ
image::bootdashboard_3.png[]

次に、同様に adminプロジェクト(AdminService)を起動します。

.Boot Dashboardにより、adminプロジェクトを起動したところ
image::bootdashboard_4.png[]

残りのプロジェクトは同時に起動します。
3つのプロジェクトを選択して、起動します。

.Boot Dashboardにより、残りの3つのプロジェクトを選択したところ
image::bootdashboard_5.png[]

以下の様に表示されていれば OKです。

.Boot Dashboardにより、全てプロジェクトを起動したところ
image::bootdashboard_6.png[]

終了は、全てのプロジェクトを選択し、停止ボタンを押下してください。


== マイクロサービスの動作確認

全てのマイクロサービスを起動すると、以下の URLが利用できるようになります。

Spring Boot Admin:: http://localhost:8110/admin +
以下の様な画面が表示されます。
`ServiceDiscovery` に登録されたマイクロサービスを自動的に管理対象とし、
各マイクロサービスの Actuatorの RESTエンドポイトにアクセスして、得られた情報を可視化します。

`Details` ボタンを押下して、色々な情報を見て試してください。

.Spring Boot Adminの起動画面
image::SpringBootAdmin_0.png[width=600]

IMPORTANT: Statusで DOWNと表示されているのは、以下の `Microservices Dashboard` の機能が
Redisサーバをデフォルトで見にいくのですが、Redisが動作していないためです。
動作には得に問題ないですが、 `Microservices Dashboard` のドキュメントに説明が無く、
未成熟と思われる所以です。

Microservices Dashboard:: http://localhost:8110 +
以下の様な画面が表示されます。
`ServiceDiscovery` に登録されたマイクロサービスにアクセスし、
各マイクロサービスのエンドポイントなどを可視化します。
(今のバージョン(Ver.1.0.1)ではまだ成熟していない感触です。今後の開発に期待します。)

.Microservices Dashboardの起動画面
image::MicroservicesDashboard.png[width=600]

FrontendService:: http://localhost:8000/frontend/ +
API Gateway経由でのアクセスになります。
今は得にページを用意していないため、デフォルトのエラーページが表示されます。

ContentsService:: http://localhost:8000/contents/ +
API Gateway経由でのアクセスになります。 +
今の設定では、HAL Browserが起動しますが、データが無いため空の profileの情報が表示されます。

NOTE: HAL(Hypertext Application Language) と HAL Browserについては以下を参照してください。 +
1. http://stateless.co/hal_specification.html +
2. http://docs.spring.io/spring-data/rest/docs/2.5.6.RELEASE/reference/html/ +
3. http://docs.spring.io/spring-data/rest/docs/2.5.6.RELEASE/reference/html/#_the_hal_browser


== おわりに

ここまでですが、 30分で終わりましたか？

手順だけであれば、30分程度で終ると思いますが、利用している技術について理解するためには、
時間がかかると思います。チャレンジして頂ければと思います。


== Acknowledgements / 謝辞

* I am very grateful to Mr. Josh Long.
** https://spring.io/blog/2016/12/07/spring-tips-bootiful-dashboards

* Many Thanks to Spring IO Platform.
** https://spring.io/platform


== このドキュメントとサンプル・コードについて

このドキュメントは、Asciidoctorにより作成しています。
実際のソースコードや設定ファイルを取り込んで、ドキュメントを作成できます。

Asciidocについては以下を、

http://asciidoctor.org/

Asciidoctorのプロジェクトの作成方法は以下を参照してください。

https://github.com/nobusugi246/asciidoctor-gradle-examples

今回作成したコードは以下にあります。

https://github.com/nobusugi246/building-msa-in-30-minutes

ドキュメントのコードは以下にあります。

src/docs/asciidoc
